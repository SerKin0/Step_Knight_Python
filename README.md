# Step Knight Python
Эта программа представляет собой решение задачи о нахождении наикратчайшего пути коня на шахматной доске от стартовой позиции до финиша за определенное количество ходов N. Она реализована на языке программирования Python и использует библиотеку matplotlib для визуализации шахматной доски.

## Содержание
- [Установка](#установка)
- [Использование](#Использование)
- [To do](#to-do)
- [Результат](#результат)
- [Тест времени](#тест-времени)

## Установка
Для установки программы вам потребуется:

1. Скачать и установить Python версии 3.9 или более поздней. Вы можете найти официальный сайт Python для загрузки [здесь](https://www.python.org/downloads/).

2. Установить необходимые зависимости, выполнив следующую команду в командной строке:
```bash
pip install matplotlib
```

## Использование
1. Запустите программу, используя команду:
```bash
python step_knight.py
```
2. Введите стартовые и конечные координаты на шахматной доске, а также количество ходов N.
3. Программа выдаст наилучший путь коня, отображенный в виде последовательности движений на шахматной доске. Она также 
может сохранить изображение доски в файле "knight_path.png".

## To do
- [x] Сделать алгоритм BFS
- [x] Сделать визуализацию доски
- [x] Сделать тест по времени
- [ ] Сделать это для других фигур

## Результат
Вводим размеры доски, координаты начала и конца пути в файле main.py.
```python
# Размеры доски
size_x, size_y = 20, 20
# Координаты начала пути коня
kn_x, kn_y = 2, 0
# Координаты конца пути коня
fn_x, fn_y = 6, 18
```
Если конь должен двигаться немного по другому, то можно изменить патерны его движения в файле algoritm.py.
```python
# Патерны движения коня на доске
pattern_x, pattern_y = [1, 2, 2, 1, -1, -2, -2, -1], [-2, -1, 1, 2, 2, 1, -1, -2]
```
Эти переменные есть каки в функции BFS, так в path_start. Учитывайте это.
![Figure_1.png](https://github.com/SerKin0/Step_Knight_Python/assets/71343548/0773a74d-bf35-4612-b0cd-1ba02007ddac)

## Тест времени
В последнем обновлении я добавил еще две функции в файл algoritm.py: BFS_recursion, BFS_cycle. 
1) BFS_cycle - в нем почти ничего не изменилось относительно функции BFS. Но вместо того, чтобы искать заново
   по всему двумерному массиву элемент с необходимым шагом, мы просто записываем в list состоящий из tuple (x, y) 
   координаты точек куда конь будет перемещаться.
2) BFS_recursion - алгоритм этой функции построен на принципе рекурсий. Он просто проходится по всем заданным 
   координатам определенного шага и раставляет шаги дальше, пока не дойдет до финиша. Есть у нее только один минус, 
   в определенный момент она может переполниться и не произвести путь.
Чтобы определить какая из функций более жизнеспособная, я решил провести тест по времени, который выполнен в файле 
   test_time.py:
1. Сначала мы будем строить для них квадратное поле размером size на size которые будут перебираться циклом for от 6 
   до n числа;
2. Устанавливаем старт в точке 0, 0, а точку финиша в size-1, size-1;
3. Дальше просто замеряем время выполнения функции:
```python
def time_fun(function, *args, **kwargs):
    start_time = time()
    try:
        function(*args, **kwargs)
    except None:
        return -1
    end_time = time() - start_time
    return end_time
```
И если функция дала сбой (например переполнение у рекурсии), то возвращаем -1, и больше не запускам функцию для 
проверки и выставляем только 0.
4. Строим график с линиями тренда.

По итогу я получил следующий график:
![Figure_3](https://github.com/SerKin0/Step_Knight_Python/assets/71343548/39a42b26-2168-42b4-88cc-2c6e372e1e41)
Подведем итог:
Изначальная функция (BFS) хоть и очень простая, но уже на размерах за 300 (как показали другие исследования) может 
выполняться от 4 секунд и более.
Вторая функция, то есть рекурсивная (BFS_recursion) показала намного лучше результат, но повторюсь она может 
переполниться и вычислить будет невозможно.
Третья, показала приблизительно похожие результаты с рекурсивной, но можно заметить две вещи: функция ни как не 
ограничена размерами массива (не может переполниться), также по линиям тренда можно увидеть что на больших массивах 
он обгоняет рекурсивной, хоть и на немножко, но и чутка проигрывает в начале.
